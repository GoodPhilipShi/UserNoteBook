---
title: 173RC2.0
date created: æ˜ŸæœŸäºŒ, äºŒæœˆ 21æ—¥ 2023, 10:05:28 ä¸Šåˆ
date modified: æ˜ŸæœŸå››, äºŒæœˆ 23æ—¥ 2023, 1:12:06 ä¸‹åˆ
---

# 173RC2.0

## å…¼å®¹å‡†å¤‡

### åµŒå…¥å¼

#### ä¸»æ¿ Esp 8266

[GitHub - esp8266/Arduino: ESP8266 core for Arduino](https://github.com/esp8266/Arduino/)

>[!done]- æ­¥éª¤â‘  ä¿å­˜ä¸€ä»½ `package_esp8266com_index.template.json`
> [Arduino/package_esp8266com_index.template.json at 78444a5037eeefd0a442b1abff4dcfd1cf74c310 Â· esp8266/Arduino (github.com)](https://github.com/esp8266/Arduino/blob/78444a5037eeefd0a442b1abff4dcfd1cf74c310/package/package_esp8266com_index.template.json)
> ![[package_esp8266com_index.template.json]]

> [!info]- æ­¥éª¤â‘¡python `get.py`
>
> ~~~python
> #!/usr/bin/env python3
> # This script will download and extract required tools into the current directory.
> # Tools list is obtained from package/package_esp8266com_index.template.json file.
> # Written by Ivan Grokhotkov, 2015.
> #
> from __future__ import print_function
> import os
> import shutil
> import errno
> import os.path
> import hashlib
> import json
> import platform
> import sys
> import tarfile
> import zipfile
> import re
> 
> verbose = True
> 
> if sys.version_info[0] == 3:
>     from urllib.request import urlretrieve
> else:
>     # Not Python 3 - today, it is most likely to be Python 2
>     from urllib import urlretrieve
> 
> dist_dir = 'dist/'
> 
> def sha256sum(filename, blocksize=65536):
>     hash = hashlib.sha256()
>     with open(filename, "rb") as f:
>         for block in iter(lambda: f.read(blocksize), b""):
>             hash.update(block)
>     return hash.hexdigest()
> 
> def mkdir_p(path):
>     try:
>         os.makedirs(path)
>     except OSError as exc:
>         if exc.errno != errno.EEXIST or not os.path.isdir(path):
>             raise
> 
> def report_progress(count, blockSize, totalSize):
>     global verbose
>     if verbose:
>         percent = int(count*blockSize*100/totalSize)
>         percent = min(100, percent)
>         sys.stdout.write("\r%d%%" % percent)
>         sys.stdout.flush()
> 
> def unpack(filename, destination):
>     dirname = ''
>     print('Extracting {0}'.format(filename))
>     if filename.endswith('tar.gz'):
>         tfile = tarfile.open(filename, 'r:gz')
>         tfile.extractall(destination)
>         dirname= tfile.getnames()[0]
>     elif filename.endswith('zip'):
>         zfile = zipfile.ZipFile(filename)
>         zfile.extractall(destination)
>         dirname = zfile.namelist()[0]
>     else:
>         raise NotImplementedError('Unsupported archive type')
> 
>     # a little trick to rename tool directories so they don't contain version number
>     rename_to = re.match(r'^([a-zA-Z_][^\-]*\-*)+', dirname).group(0).strip('-')
>     if rename_to != dirname:
>         sourceDirName = os.path.join(destination, dirname)
>         targetDirName = os.path.join(destination, rename_to)
>         print('Renaming {0} to {1}'.format(sourceDirName, targetDirName))
>         if os.path.isdir(targetDirName):
>             shutil.rmtree(targetDirName)
>         shutil.move(sourceDirName, targetDirName)
> 
> def get_tool(tool, unpackPath):
>     archive_name = tool['archiveFileName']
>     local_path = dist_dir + archive_name
>     url = tool['url']
>     real_hash = tool['checksum'].split(':')[1]
>     if not os.path.isfile(local_path):
>         print('Downloading ' + archive_name);
>         urlretrieve(url, local_path, report_progress)
>         sys.stdout.write("\rDone\n")
>         sys.stdout.flush()
>     else:
>         print('Tool {0} already downloaded'.format(archive_name))
>     local_hash = sha256sum(local_path)
>     if local_hash != real_hash:
>         print('Hash mismatch for {0}, delete the file and try again'.format(local_path))
>         raise RuntimeError()
>     if unpackPath:
>         unpack(local_path, unpackPath)
>     else:
>         unpack(local_path, '.')
> 
> def load_tools_list(filename, platform):
>     tools_info = json.load(open(filename))['packages'][0]['tools']
>     tools_to_download = []
>     for t in tools_info:
>         tool_platform = [p for p in t['systems'] if p['host'] == platform]
>         if len(tool_platform) == 0:
>             continue
>         tools_to_download.append(tool_platform[0])
>     return tools_to_download
> 
> def identify_platform():
>     arduino_platform_names = {'Darwin'  : {32 : 'i386-apple-darwin',   64 : 'x86_64-apple-darwin'},
>                               'Linux'   : {32 : 'i686-pc-linux-gnu',   64 : 'x86_64-pc-linux-gnu'},
>                               'LinuxARM': {32 : 'arm-linux-gnueabihf', 64 : 'aarch64-linux-gnu'},
>                               'Windows' : {32 : 'i686-mingw32',        64 : 'x86_64-mingw32'}}
>     bits = 32
>     if sys.maxsize > 2**32:
>         bits = 64
>     sys_name = platform.system()
>     if 'Linux' in sys_name and (platform.platform().find('arm') > 0 or platform.platform().find('aarch64') > 0):
>         sys_name = 'LinuxARM'
>     if 'CYGWIN_NT' in sys_name:
>         sys_name = 'Windows'
>     if 'MSYS_NT' in sys_name:
>         sys_name = 'Windows'
>     if 'MINGW' in sys_name:
>         sys_name = 'Windows'
>     return arduino_platform_names[sys_name][bits]
> 
> def main(fileJSON, name):
>     global verbose
>     # Support optional "-q" quiet mode simply
>     if len(sys.argv) == 2:
>         if sys.argv[1] == "-q":
>             verbose = False
>     # Remove a symlink generated in 2.6.3 which causes later issues since the tarball can't properly overwrite it
>     if (os.path.exists('python3/python3')):
>         os.unlink('python3/python3')
>     print('Platform: {0}'.format(identify_platform()))
>     tools_to_download = load_tools_list(fileJSON, identify_platform())
>     mkdir_p(dist_dir)
>     mkdir_p(name)
>     for tool in tools_to_download:
>         get_tool(tool, name)
> 
> if __name__ == '__main__':
>     main('package_esp8266com_index.template.json', "eps8266")
> ~~~

![[Pasted image 20230221101412.png]]
![[Pasted image 20230221101446.png]]

#### ä¸»æ¿ Pico

>[!done]- æ­¥éª¤â‘  ä¿å­˜ä¸€ä»½ `package_pico_index.template.json`
> [arduino-pico/package\_pico\_index.template.json at master Â· earlephilhower/arduino-pico Â· GitHub](https://github.com/earlephilhower/arduino-pico/blob/master/package/package_pico_index.template.json)
> ![[package_pico_index.template.json]]

> [!info]- æ­¥éª¤â‘¡python `get.py`
>
> ~~~python
> #!/usr/bin/env python3
> # This script will download and extract required tools into the current directory.
> # Tools list is obtained from package/package_esp8266com_index.template.json file.
> # Written by Ivan Grokhotkov, 2015.
> #
> from __future__ import print_function
> import os
> import shutil
> import errno
> import os.path
> import hashlib
> import json
> import platform
> import sys
> import tarfile
> import zipfile
> import re
> 
> verbose = True
> 
> if sys.version_info[0] == 3:
>     from urllib.request import urlretrieve
> else:
>     # Not Python 3 - today, it is most likely to be Python 2
>     from urllib import urlretrieve
> 
> dist_dir = 'dist/'
> 
> def sha256sum(filename, blocksize=65536):
>     hash = hashlib.sha256()
>     with open(filename, "rb") as f:
>         for block in iter(lambda: f.read(blocksize), b""):
>             hash.update(block)
>     return hash.hexdigest()
> 
> def mkdir_p(path):
>     try:
>         os.makedirs(path)
>     except OSError as exc:
>         if exc.errno != errno.EEXIST or not os.path.isdir(path):
>             raise
> 
> def report_progress(count, blockSize, totalSize):
>     global verbose
>     if verbose:
>         percent = int(count*blockSize*100/totalSize)
>         percent = min(100, percent)
>         sys.stdout.write("\r%d%%" % percent)
>         sys.stdout.flush()
> 
> def unpack(filename, destination):
>     dirname = ''
>     print('Extracting {0}'.format(filename))
>     if filename.endswith('tar.gz'):
>         tfile = tarfile.open(filename, 'r:gz')
>         tfile.extractall(destination)
>         dirname= tfile.getnames()[0]
>     elif filename.endswith('zip'):
>         zfile = zipfile.ZipFile(filename)
>         zfile.extractall(destination)
>         dirname = zfile.namelist()[0]
>     else:
>         raise NotImplementedError('Unsupported archive type')
> 
>     # a little trick to rename tool directories so they don't contain version number
>     rename_to = re.match(r'^([a-zA-Z_][^\-]*\-*)+', dirname).group(0).strip('-')
>     if rename_to != dirname:
>         sourceDirName = os.path.join(destination, dirname)
>         targetDirName = os.path.join(destination, rename_to)
>         print('Renaming {0} to {1}'.format(sourceDirName, targetDirName))
>         if os.path.isdir(targetDirName):
>             shutil.rmtree(targetDirName)
>         shutil.move(sourceDirName, targetDirName)
> 
> def get_tool(tool, unpackPath):
>     archive_name = tool['archiveFileName']
>     local_path = dist_dir + archive_name
>     url = tool['url']
>     real_hash = tool['checksum'].split(':')[1]
>     if not os.path.isfile(local_path):
>         print('Downloading ' + archive_name);
>         urlretrieve(url, local_path, report_progress)
>         sys.stdout.write("\rDone\n")
>         sys.stdout.flush()
>     else:
>         print('Tool {0} already downloaded'.format(archive_name))
>     local_hash = sha256sum(local_path)
>     if local_hash != real_hash:
>         print('Hash mismatch for {0}, delete the file and try again'.format(local_path))
>         raise RuntimeError()
>     if unpackPath:
>         unpack(local_path, unpackPath)
>     else:
>         unpack(local_path, '.')
> 
> def load_tools_list(filename, platform):
>     tools_info = json.load(open(filename))['packages'][0]['tools']
>     tools_to_download = []
>     for t in tools_info:
>         tool_platform = [p for p in t['systems'] if p['host'] == platform]
>         if len(tool_platform) == 0:
>             continue
>         tools_to_download.append(tool_platform[0])
>     return tools_to_download
> 
> def identify_platform():
>     arduino_platform_names = {'Darwin'  : {32 : 'i386-apple-darwin',   64 : 'x86_64-apple-darwin'},
>                               'Linux'   : {32 : 'i686-pc-linux-gnu',   64 : 'x86_64-pc-linux-gnu'},
>                               'LinuxARM': {32 : 'arm-linux-gnueabihf', 64 : 'aarch64-linux-gnu'},
>                               'Windows' : {32 : 'i686-mingw32',        64 : 'x86_64-mingw32'}}
>     bits = 32
>     if sys.maxsize > 2**32:
>         bits = 64
>     sys_name = platform.system()
>     if 'Linux' in sys_name and (platform.platform().find('arm') > 0 or platform.platform().find('aarch64') > 0):
>         sys_name = 'LinuxARM'
>     if 'CYGWIN_NT' in sys_name:
>         sys_name = 'Windows'
>     if 'MSYS_NT' in sys_name:
>         sys_name = 'Windows'
>     if 'MINGW' in sys_name:
>         sys_name = 'Windows'
>     return arduino_platform_names[sys_name][bits]
> 
> def main(fileJSON, name):
>     global verbose
>     # Support optional "-q" quiet mode simply
>     if len(sys.argv) == 2:
>         if sys.argv[1] == "-q":
>             verbose = False
>     # Remove a symlink generated in 2.6.3 which causes later issues since the tarball can't properly overwrite it
>     if (os.path.exists('python3/python3')):
>         os.unlink('python3/python3')
>     print('Platform: {0}'.format(identify_platform()))
>     tools_to_download = load_tools_list(fileJSON, identify_platform())
>     mkdir_p(dist_dir)
>     mkdir_p(name)
>     for tool in tools_to_download:
>         get_tool(tool, name)
> 
> if __name__ == '__main__':
>     main('package_pico_index.template.json', "rp2040")
> ~~~

### Python

[Python Release Python 3.8.5 | Python.org](https://www.python.org/downloads/release/python-385/)

>[!tip] ç”±äºŽç¼–è¯‘ä¸€ç›´ä¸æˆåŠŸï¼Œæ‰€ä»¥æ”¹æˆå®‰è£… 3.8.5ï¼Œç„¶åŽå†æŠŠ Python 3.8.5 æå–å‡ºæ¥
>

>[!info] Python åœ¨ Mac OS ä¸­çš„å®‰è£…è·¯å¾„
> `/Library/Frameworks/Python.framework/Versions/`

>[!done] ç„¶åŽæŠŠç›¸åº”çš„ç‰ˆæœ¬ä¸­çš„ `bin`ã€`include`ã€`lib`ã€`share` æå–å‡ºæ¥ï¼Œå¹¶ä¸”åŽ‹ç¼©ä¸º `Python-3.8.5-åº•åŒ….zip` ä¿å­˜ä¸€ä»½

#### å®‰è£…åº“

>[!example] Python 3.8.5 åº“åˆ—è¡¨ for Mind+ 173 RC 2.0
>ä¸ç”¨æŒ‡å®š Python ç‰ˆæœ¬

| åº“            | ç‰ˆæœ¬     | å¤‡æ³¨     |
| ------------- | -------- | -------- |
| opencv-python | 4.5.5.64 |          |
| siot          | *        |          |
| xlrd          | 2.0.1    |          |
| xlwt          | 1.3.0    |          |
| schedule      | 1.1.0    |          |
| requests      | 2.27.1   |          |
| PyAutoGUI     | 0.9.53   |          |
| pygame        | 2.0.1    |          |
| unihiker      | *        |          |
| jedi          | 0.18.1   | ä»£ç è¡¥å…… |
| baidu-aip     | *        |          |
| pinpong              |*          |          |

```shell
./bin/python3 -m pip install opencv-python siot xlrd xlwt schedule PyAutoGUI pygame unihiker jedi baidu-aip
```

## åµŒå…¥å¼: ç¼–è¯‘ SDK

>[!info] MAC ä¸­çœŸæ­£ä¼šå‡ºçŽ°é—®é¢˜çš„ä¸»æ¿
>1. `pico`
>2. `fireBeetleEsp32E`
>3. `esp8266`
>å…¶ä½™ä¸»æ¿åªéœ€è¦é‡æ–°ç¼–è¯‘å³å¯

### fireBeetleEsp32E

```shell
\===error ||| Error resolving FQBN: {0} ||| [getting build properties for board dfrobot:mpython:fireBeetleEsp32E: invalid option 'FlashMode']
```

>[!tip] åˆ é™¤ä¸Ž FlashMode ç›¸å…³çš„é…ç½®é€‰é¡¹
>~~~diff
> - -fqbn=dfrobot:mpython:fireBeetleEsp32E:FlashMode=qio, FlashFreq=80, UploadSpeed=921600, DebugLevel=none
> + -fqbn=dfrobot:mpython:fireBeetleEsp32E:UploadSpeed=921600, DebugLevel=none
>~~~

> [!done] æµ‹è¯•: Mac, Windows, Linux (Ubuntu) å¯ä»¥ç¼–è¯‘æˆåŠŸ

### esp8266

>[!tip] æŠ¥é”™

>[!info] ðŸ”Žå¯»æ‰¾å‡ºé•œçŽ‡é«˜çš„ `.h` æ–‡ä»¶è¿›è¡Œå•ç‹¬ç¼–è¯‘
>~~~shell
>python ofile.py --build --includes -b esp8266 -l DFRobot_PS2X.h
>~~~
>å¦‚æžœç¼–è¯‘å¤±è´¥ï¼Œé‚£å°±å°è¯•å…¶ä»–æ–¹æ³•
>å¦‚æžœç¼–è¯‘æˆåŠŸ, å°±ä¿®æ”¹ `mindPlus/Arduino/libraries/DFRobot_PS2X/config.json` æ–‡ä»¶, å±è”½è¿™ä¸ªåº“ï¼ŒåŽé¢å•ç‹¬ç¼–è¯‘

>[!example] æ‰¾åˆ°å¦‚ä¸‹å‡ ä¸ªåº“
>1. `DFRobot_PS2X.h`

### pico

>[!tip] æŠ¥é”™

>[!info] ðŸ”Žå¯»æ‰¾å‡ºé•œçŽ‡é«˜çš„ `.h` æ–‡ä»¶è¿›è¡Œå•ç‹¬ç¼–è¯‘
>~~~shell
>python ofile.py --build --includes -b esp8266 -l DFRobot_PS2X.h
>~~~
>å¦‚æžœç¼–è¯‘å¤±è´¥ï¼Œé‚£å°±å°è¯•å…¶ä»–æ–¹æ³•
>å¦‚æžœç¼–è¯‘æˆåŠŸ, å°±ä¿®æ”¹ `mindPlus/Arduino/libraries/DFRobot_PS2X/config.json` æ–‡ä»¶, å±è”½è¿™ä¸ªåº“ï¼ŒåŽé¢å•ç‹¬ç¼–è¯‘

>[!example] æ‰¾åˆ°å¦‚ä¸‹å‡ ä¸ªåº“
>1. `DFRobot_BH1750.h`
>2. `DFRobot_Obloq_I2C.h`
>3. `DFRobot_LiquidCrystal_I2C.h`
>4. `DFRobot_TDS.h`
>5. `DFRobot_PS2X.h`
>6. `DFRobot_HuskyLens.h`
>7. `DFRobot_SSD1306_I2C.h`
>8. `DFRobot_LedControl.h`
>
>>[!done] ç»è¿‡æµ‹è¯•ï¼Œå‡é€šè¿‡ç¼–è¯‘

#### ä¿®æ”¹ gcc ç¼–è¯‘å·¥å…·çš„æŒ‡å®šè·¯å¾„

```diff
- compiler.path={runtime.tools.avr-gcc.path}/../nRF5/pqt-arm-none-eabi-gcc/bin/
+ compiler.path={runtime.tools.avr-gcc.path}/../rp2040/pqt-arm-none-eabi-gcc/bin/
```

>[!tip] ç„¶è€Œè¿˜æ˜¯å·®ä¸å¤š

#### æ”¹æˆä¸€ä¸ªä¸€ä¸ªçš„ç¼–è¯‘

>[!info]- è¿è¡Œ `buildOneInAll.py`
> ~~~python
> import os, json, math
> 
> arduinoDir = os.path.abspath(os.path.join(os.getcwd(), "../"))
> 
> libPath = [
>     os.path.abspath(os.path.join(arduinoDir, "./libraries")),
>     os.path.abspath(os.path.join(arduinoDir, "./hardware/dfrobot/mpython/libraries")),
>     os.path.abspath(os.path.join(arduinoDir, "./hardware/dfrobot/nRF5/libraries")),
>     os.path.abspath(os.path.join(arduinoDir, "./hardware/dfrobot/nRF52/libraries")),
>     os.path.abspath(os.path.join(arduinoDir, "./hardware/arduino/avr/libraries")),
>     os.path.abspath(os.path.join(arduinoDir, "./hardware/dfrobot/nRF5/cores")),
>     os.path.abspath(os.path.join(arduinoDir, "./hardware/dfrobot/nRF52/cores")),
>     os.path.abspath(os.path.join(arduinoDir, "./hardware/dfrobot/mpython/cores")),
>     os.path.abspath(os.path.join(arduinoDir, "./hardware/arduino/avr/cores"))
> ]
> 
> def loadBoardLib(board):
>     boardLib = []
>     for index in libPath:
>         print(index)
>         listdir = os.listdir(index)
>         for i in range(0, len(listdir)):
>             path = os.path.join(index, listdir[i])
>             configPath = path + "/config.json"
>             if os.path.isfile(configPath):
>                 with open(configPath) as f:
>                     data = json.loads(f.read())
>                     if data.get(board):
>                         include = data.get("include")
>                         if type(include) == list:
>                             boardLib.extend(include)
>                         elif type(include) == str:
>                             boardLib.append(include)
>                         else:
>                             print("å¥‡æ€ªçš„ç±»åž‹", type(include))
>         return boardLib
> err=[]
> division = 1
> microbitLibs = loadBoardLib("pico")
> print(f"å½“å‰ pico å­˜åœ¨ {len(microbitLibs)} ä¸ªåº“")
> maxSun = math.ceil(len(microbitLibs) / division)
> print(f"æ¯{division}ä¸ªä¸ºä¸€ç»„ ä¸€å…± {maxSun} ç»„")
> for i in range(1, maxSun):
>     if i == maxSun:
>         print((i - 1) * division)
>         libs = microbitLibs[(i - 1) * division: ]
>     else :
>         libs = microbitLibs[(i - 1) * division: i * division]
>     _commad = ",".join(libs)
>     commad = f"python ofile.py --build --includes -b pico --librarie {_commad}"
>     print(i, commad)
>     if os.system(command = commad) != 0:
>         err.extend(libs)
> 
> print(err)
> ~~~

>[!done] ç¼–è¯‘æ²¡æœ‰ä»»ä½•é—®é¢˜